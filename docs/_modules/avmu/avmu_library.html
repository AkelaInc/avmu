
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>avmu.avmu_library &#8212; Akela AVMU  documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for avmu.avmu_library</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># #########################################################################</span>

<span class="sd">Python api to AKELA Inc&#39;s AVMU hardware.</span>

<span class="sd">Note: This library is a relatively thin wrapper on top of</span>
<span class="sd">the C/C++ AVMU DLL interface. In general, the documentation</span>
<span class="sd">for the C interface is more complete, and generally more likely</span>
<span class="sd">to be kept completely up to date. Please check that documentation</span>
<span class="sd">in case of ambiguities, before contacting support.</span>

<span class="sd">Author: Connor Wolf &lt;cwolf@akelainc.com&gt;</span>

<span class="sd"># #########################################################################</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">dll_loader</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">avmu_exceptions</span>

<div class="viewcode-block" id="AvmuInterface"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface">[docs]</a><span class="k">class</span> <span class="nc">AvmuInterface</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>



	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">share_from_interface</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Create the base AVMU interface class.</span>

<span class="sd">		For multi-AVMU operation, pass the first created interface</span>
<span class="sd">		to any additional interface class instances. This allows all</span>
<span class="sd">		the interface instances to share the same underlying communication</span>
<span class="sd">		objects, which is needed for synchronized operation.</span>

<span class="sd">		Note: If you don&#39;t share the communcation object, calls</span>
<span class="sd">		such as broadcastBeginCommand() will not operate properly.</span>

<span class="sd">		Unfortunately, there is no coherent way to validate this</span>
<span class="sd">		in the library code, so it&#39;s left up to the user.</span>

<span class="sd">		Note: All library functions can theoretically raise  :class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Handle`</span>
<span class="sd">		if the internal task handle has been corrupted. As such, this particular exception will not be explicitly</span>
<span class="sd">		enumerated for every possible call.</span>

<span class="sd">		&#39;&#39;&#39;</span>


		<span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;Main.Dll&quot;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading DLL&quot;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span> <span class="o">=</span> <span class="n">dll_loader</span><span class="o">.</span><span class="n">load_ffi_interface</span><span class="p">()</span>

		<span class="k">if</span> <span class="s2">&quot;Private API mode&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">versionString</span><span class="p">():</span>
			<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">private_api</span>
			<span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">private_api</span><span class="o">.</span><span class="n">PromOverrideAvmuInterface</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Constructing constant mapping tables.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">___construct_map_tables</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__createTask</span><span class="p">(</span><span class="n">share_from_interface</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">measured_paths</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">serial_buf_sz</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">active_receivers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">__deleteTask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Error when trying to delete task handle!&quot;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2"> for radar </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2"> state </span><span class="si">{}</span><span class="s2">, handle </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
			<span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">getIPAddress</span><span class="p">(),</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">getIPPort</span><span class="p">(),</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">getState</span><span class="p">(),</span>

			<span class="c1"># This is legit kind of horrible.</span>
			<span class="c1"># Only thing that makes it even marginally not-bad is that</span>
			<span class="c1"># it&#39;s only for printing an error message.</span>
			<span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="p">)</span>

		<span class="k">return</span> <span class="n">ret</span>


	<span class="k">def</span> <span class="nf">__getRawTaskHandle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__getRawTaskHandle call&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span>

	<span class="k">def</span> <span class="nf">__createTask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fromtask</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__createTask call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: TaskHandle createTask();</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating task.&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">fromtask</span><span class="p">:</span>
			<span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">createSharedTask</span><span class="p">(</span><span class="n">fromtask</span><span class="o">.</span><span class="n">__getRawTaskHandle</span><span class="p">())</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">createTask</span><span class="p">()</span>

		<span class="k">return</span> <span class="n">th</span>

	<span class="k">def</span> <span class="nf">__deleteTask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_handle</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__deleteTask call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: void deleteTask(TaskHandle t);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Destroying task.&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">deleteTask</span><span class="p">(</span><span class="n">task_handle</span><span class="p">)</span>


	<span class="k">def</span> <span class="nf">___construct_map_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>




		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;___construct_map_tables call&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="p">{</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_OK</span>                                 <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_ATTEN</span>                          <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Atten</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_CAL</span>                            <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Cal</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_HANDLE</span>                         <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Handle</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_HOP</span>                            <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Hop</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_PATH</span>                           <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Path</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_PROM</span>                           <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Prom</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BYTES</span>                              <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bytes</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_EMPTY_PROM</span>                         <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Empty_Prom</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_FEATURE_NOT_PRESENT</span>                <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Feature_Not_Present</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_FREQ_OUT_OF_BOUNDS</span>                 <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Freq_Out_Of_Bounds</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_INTERRUPTED</span>                        <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Interrupted</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_MISSING_ATTEN</span>                      <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Missing_Atten</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_MISSING_FREQS</span>                      <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Missing_Freqs</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_MISSING_HOP</span>                        <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Missing_Hop</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_MISSING_IP</span>                         <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Missing_Ip</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_MISSING_PORT</span>                       <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Missing_Port</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_NO_ATTEN_PRESENT</span>                   <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_No_Attenuator_Present</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_NO_PATHS_MEASURED</span>                  <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_No_Measured_Paths</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_NO_RESPONSE</span>                        <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_No_Response</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_PATH_ALREADY_MEASURED</span>              <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Path_Already_Measured</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_PROG_OVERFLOW</span>                      <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Prog_Overflow</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_SOCKET</span>                             <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Socket</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_TOO_MANY_POINTS</span>                    <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Too_Many_Points</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_UNKNOWN_FEATURE</span>                    <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Unknown_Feature</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_WRONG_PROGRAM_TYPE</span>                 <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Wrong_Program_Type</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_WRONG_STATE</span>                        <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Wrong_State</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_BAD_IP_PORT</span>                        <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_IP_Port</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_TASK_ARRAY_INVALID</span>                 <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Task_Array_Invalid</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">ERR_PATH_HAS_NO_DATA</span>                   <span class="p">:</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Path_Has_No_Data</span><span class="p">,</span>
			<span class="c1"># self.dll.ERR_INDEX_OUT_OF_BOUNDS                : avmu_exceptions.Avmu_Exception_Err_Index_Out_Of_Bounds,</span>
			<span class="c1"># self.dll.ERR_INVALID_PARAMETER                  : avmu_exceptions.Avmu_Exception_Err_Invalid_Parameter,</span>
			<span class="c1"># self.dll.ERR_PROM_INVALID_FEATURE_CONFIGURATION : avmu_exceptions.Avmu_Exception_Err_Prom_Invalid_Feature_Configuration,</span>

		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">hops</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;HOP_UNDEFINED&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_UNDEFINED</span><span class="p">,</span>
			<span class="s1">&#39;HOP_90K&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_90K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_45K&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_45K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_30K&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_30K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_15K&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_15K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_7K&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_7K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_3K&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_3K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_2K&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_2K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_1K&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_1K</span><span class="p">,</span>
			<span class="s1">&#39;HOP_550&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_550</span><span class="p">,</span>
			<span class="s1">&#39;HOP_312&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_312</span><span class="p">,</span>
			<span class="s1">&#39;HOP_156&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_156</span><span class="p">,</span>
			<span class="s1">&#39;HOP_78&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_78</span><span class="p">,</span>
			<span class="s1">&#39;HOP_39&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_39</span><span class="p">,</span>
			<span class="s1">&#39;HOP_20&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">HOP_20</span><span class="p">,</span>
		<span class="p">}</span>


		<span class="bp">self</span><span class="o">.</span><span class="n">tx_paths</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;AVMU_TX_PATH_0&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_0</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_1&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_1</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_2&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_2</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_3&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_3</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_4&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_4</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_5&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_5</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_6&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_6</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_7&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_7</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_NONE&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_NONE</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">rx_paths</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;AVMU_RX_PATH_0&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_0</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_1&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_1</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_2&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_2</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_3&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_3</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_4&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_4</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_5&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_5</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_6&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_6</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_7&#39;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_7</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_NONE&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_NONE</span><span class="p">,</span>
		<span class="p">}</span>


		<span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_int</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;AVMU_TX_PATH_0&#39;</span>    <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_1&#39;</span>    <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_2&#39;</span>    <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_3&#39;</span>    <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_4&#39;</span>    <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_5&#39;</span>    <span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_6&#39;</span>    <span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_7&#39;</span>    <span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_TX_PATH_NONE&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_int</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;AVMU_RX_PATH_0&#39;</span>    <span class="p">:</span>  <span class="mi">0</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_1&#39;</span>    <span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_2&#39;</span>    <span class="p">:</span>  <span class="mi">2</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_3&#39;</span>    <span class="p">:</span>  <span class="mi">3</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_4&#39;</span>    <span class="p">:</span>  <span class="mi">4</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_5&#39;</span>    <span class="p">:</span>  <span class="mi">5</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_6&#39;</span>    <span class="p">:</span>  <span class="mi">6</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_7&#39;</span>    <span class="p">:</span>  <span class="mi">7</span><span class="p">,</span>
			<span class="s1">&#39;AVMU_RX_PATH_NONE&#39;</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_int_enum</span> <span class="o">=</span> <span class="p">{</span>
			 <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_0</span><span class="p">,</span>
			 <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_1</span><span class="p">,</span>
			 <span class="mi">2</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_2</span><span class="p">,</span>
			 <span class="mi">3</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_3</span><span class="p">,</span>
			 <span class="mi">4</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_4</span><span class="p">,</span>
			 <span class="mi">5</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_5</span><span class="p">,</span>
			 <span class="mi">6</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_6</span><span class="p">,</span>
			 <span class="mi">7</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_7</span><span class="p">,</span>
			<span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_NONE</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_int_enum</span> <span class="o">=</span> <span class="p">{</span>
			 <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_0</span><span class="p">,</span>
			 <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_1</span><span class="p">,</span>
			 <span class="mi">2</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_2</span><span class="p">,</span>
			 <span class="mi">3</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_3</span><span class="p">,</span>
			 <span class="mi">4</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_4</span><span class="p">,</span>
			 <span class="mi">5</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_5</span><span class="p">,</span>
			 <span class="mi">6</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_6</span><span class="p">,</span>
			 <span class="mi">7</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_7</span><span class="p">,</span>
			<span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_NONE</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_enum_int</span> <span class="o">=</span> <span class="p">{</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_0</span>    <span class="p">:</span>  <span class="mi">0</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_1</span>    <span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_2</span>    <span class="p">:</span>  <span class="mi">2</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_3</span>    <span class="p">:</span>  <span class="mi">3</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_4</span>    <span class="p">:</span>  <span class="mi">4</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_5</span>    <span class="p">:</span>  <span class="mi">5</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_6</span>    <span class="p">:</span>  <span class="mi">6</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_7</span>    <span class="p">:</span>  <span class="mi">7</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_NONE</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>

		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_enum_int</span> <span class="o">=</span> <span class="p">{</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_0</span>    <span class="p">:</span>  <span class="mi">0</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_1</span>    <span class="p">:</span>  <span class="mi">1</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_2</span>    <span class="p">:</span>  <span class="mi">2</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_3</span>    <span class="p">:</span>  <span class="mi">3</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_4</span>    <span class="p">:</span>  <span class="mi">4</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_5</span>    <span class="p">:</span>  <span class="mi">5</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_6</span>    <span class="p">:</span>  <span class="mi">6</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_7</span>    <span class="p">:</span>  <span class="mi">7</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_NONE</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_enum_str</span> <span class="o">=</span> <span class="p">{</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_0</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_0&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_1</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_1&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_2</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_2&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_3</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_3&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_4</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_4&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_5</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_5&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_6</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_6&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_7</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_7&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_TX_PATH_NONE</span> <span class="p">:</span> <span class="s1">&#39;AVMU_TX_PATH_NONE&#39;</span><span class="p">,</span>

		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_enum_str</span> <span class="o">=</span> <span class="p">{</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_0</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_0&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_1</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_1&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_2</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_2&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_3</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_3&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_4</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_4&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_5</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_5&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_6</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_6&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_7</span>    <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_7&#39;</span><span class="p">,</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_RX_PATH_NONE</span> <span class="p">:</span> <span class="s1">&#39;AVMU_RX_PATH_NONE&#39;</span><span class="p">,</span>
		<span class="p">}</span>


		<span class="bp">self</span><span class="o">.</span><span class="n">prog_type</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;PROG_ASYNC&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">PROG_ASYNC</span><span class="p">,</span>
			<span class="s1">&#39;PROG_SYNC&#39;</span>           <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">PROG_SYNC</span><span class="p">,</span>

		<span class="p">}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">run_state</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;TASK_RUNNING&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">TASK_RUNNING</span><span class="p">,</span>
			<span class="s1">&#39;TASK_STARTED&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">TASK_STARTED</span><span class="p">,</span>
			<span class="s1">&#39;TASK_STOPPED&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">TASK_STOPPED</span><span class="p">,</span>
			<span class="s1">&#39;TASK_UNINITIALIZED&#39;</span>  <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">TASK_UNINITIALIZED</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sync_pulse_mode</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;SYNC_IGNORE&#39;</span>         <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">SYNC_IGNORE</span><span class="p">,</span>
			<span class="s1">&#39;SYNC_GENERATE&#39;</span>       <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">SYNC_GENERATE</span><span class="p">,</span>
			<span class="s1">&#39;SYNC_RECEIVE&#39;</span>        <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">SYNC_RECEIVE</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">if_gain_settings</span> <span class="o">=</span> <span class="p">{</span>
				<span class="s1">&#39;AVMU_GAIN_USE_DEFAULT&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_USE_DEFAULT</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_0&#39;</span>           <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_0</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_3&#39;</span>           <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_3</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_6&#39;</span>           <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_6</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_9&#39;</span>           <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_9</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_12&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_12</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_15&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_15</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_18&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_18</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_21&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_21</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_24&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_24</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_27&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_27</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_30&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_30</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_33&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_33</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_36&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_36</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_39&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_39</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_42&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_42</span><span class="p">,</span>
				<span class="s1">&#39;AVMU_GAIN_45&#39;</span>          <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_45</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">if_gain_inverse</span> <span class="o">=</span> <span class="p">{</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_USE_DEFAULT</span> <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_USE_DEFAULT&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_0</span>           <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_0&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_3</span>           <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_3&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_6</span>           <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_6&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_9</span>           <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_9&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_12</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_12&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_15</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_15&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_18</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_18&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_21</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_21&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_24</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_24&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_27</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_27&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_30</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_30&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_33</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_33&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_36</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_36&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_39</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_39&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_42</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_42&#39;</span><span class="p">,</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">AVMU_GAIN_45</span>          <span class="p">:</span> <span class="s1">&#39;AVMU_GAIN_45&#39;</span><span class="p">,</span>
		<span class="p">}</span>


	<span class="k">def</span> <span class="nf">__check_ret</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_val</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__check_ret call&quot;</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getState</span><span class="p">()</span>
		<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to query current state!&quot;</span><span class="p">)</span>
			<span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;Unknown!&quot;</span>

		<span class="k">assert</span> <span class="n">ret_val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">,</span> <span class="s2">&quot;Unknown returned error code: </span><span class="si">%s</span><span class="s2">. Current state: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="n">ret_val</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">err</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">err</span><span class="p">(</span><span class="s2">&quot;Call returned error value: </span><span class="si">%s</span><span class="s2">. Current state: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ret_val</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>


	<span class="c1">#################################################################################</span>
	<span class="c1">#        Configuration</span>
	<span class="c1">#################################################################################</span>

<div class="viewcode-block" id="AvmuInterface.addPathToMeasure"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.addPathToMeasure">[docs]</a>	<span class="k">def</span> <span class="nf">addPathToMeasure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx_path</span><span class="p">,</span> <span class="n">rx_path</span><span class="p">,</span> <span class="n">who_is_transmitting</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">port_is_transmitting</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Add a path to measure.</span>

<span class="sd">		Adds a path to the list of active paths that will be</span>
<span class="sd">		measured when data is actually acquired.</span>

<span class="sd">		Args:</span>
<span class="sd">			tx_path (str): Transmitting port of the path to add. Note that</span>
<span class="sd">			                 this can very well be TX_NONE, if your application is</span>
<span class="sd">			                 using multiple AVMUs, and one of the other AVMUs is</span>
<span class="sd">			                 the one actively transmitting.</span>
<span class="sd">			rx_path (str): RX Path for the combo. This can be RX_NONE if there</span>
<span class="sd">			                is no need for the associated rx data. Note that RX_NONE</span>
<span class="sd">			                will still return data (as the transmitter will still</span>
<span class="sd">			                need to do the associated frequency stepping), but the</span>
<span class="sd">			                return content will be only cross-board leakage within</span>
<span class="sd">			                the AVMU.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Nothing</span>

<span class="sd">		raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Path`:   if a path value specified is invalid.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;addPathToMeasure call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode addPathToMeasure(TaskHandle t, RFPath path);</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">tx_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths</span><span class="p">:</span> <span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Path</span><span class="p">(</span><span class="s2">&quot;Invalid TX Path: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tx_path</span><span class="p">,</span> <span class="p">))</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">rx_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths</span><span class="p">:</span> <span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Bad_Path</span><span class="p">(</span><span class="s2">&quot;Invalid RX Path: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rx_path</span><span class="p">,</span> <span class="p">))</span>

		<span class="n">items</span> <span class="o">=</span> <span class="p">[</span>
			<span class="p">(</span><span class="s2">&quot;tx_path&quot;</span><span class="p">,</span>              <span class="n">tx_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
			<span class="p">(</span><span class="s2">&quot;rx_path&quot;</span><span class="p">,</span>              <span class="n">rx_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span>
			<span class="p">(</span><span class="s2">&quot;who_is_transmitting&quot;</span><span class="p">,</span>  <span class="n">who_is_transmitting</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))),</span>
			<span class="p">(</span><span class="s2">&quot;port_is_transmitting&quot;</span><span class="p">,</span> <span class="n">port_is_transmitting</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>
		<span class="p">]</span>

		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">expected_type</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
			<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">),</span> <span class="s2">&quot;Parameter </span><span class="si">%s</span><span class="s2"> is not of expected type (</span><span class="si">%s</span><span class="s2">). Passed type </span><span class="si">%s</span><span class="s2">, value </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
				<span class="n">name</span><span class="p">,</span> <span class="n">expected_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding path to measure: </span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="s2"> (transmiting:  </span><span class="si">%s</span><span class="s2"> -&gt; </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">tx_path</span><span class="p">,</span> <span class="n">rx_path</span><span class="p">,</span> <span class="n">who_is_transmitting</span><span class="p">,</span> <span class="n">port_is_transmitting</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">measured_paths</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">who_is_transmitting</span><span class="p">,</span> <span class="n">port_is_transmitting</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_int</span><span class="p">[</span><span class="n">tx_path</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_int</span><span class="p">[</span><span class="n">rx_path</span><span class="p">]))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">addPathToMeasure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths</span><span class="p">[</span><span class="n">tx_path</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths</span><span class="p">[</span><span class="n">rx_path</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.clearMeasuredPaths"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.clearMeasuredPaths">[docs]</a>	<span class="k">def</span> <span class="nf">clearMeasuredPaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Clear list of paths being measured.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Nothing</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;clearMeasuredPaths call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode clearMeasuredPaths(TaskHandle t);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Clearing measured paths&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">measured_paths</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">clearMeasuredPaths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getFrequencies"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getFrequencies">[docs]</a>	<span class="k">def</span> <span class="nf">getFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">		Get a list containing the actual frequencies the hardware will sample for</span>
<span class="sd">		the configured sweep in task `t`. Units are MHz.</span>

<span class="sd">		The actual frequency points can differ from the requested frequency points</span>
<span class="sd">		because the hardware has fixed precision, and cannot achieve every arbitrary</span>
<span class="sd">		frequency value within its tunable bands. The values in this list are the</span>
<span class="sd">		requested frequency points after snapping them to the closest achievable</span>
<span class="sd">		frequency.</span>

<span class="sd">		Returns:</span>
<span class="sd">			list of floating point frequencies, in MHz</span>


<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getFrequencies call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode getFrequencies(TaskHandle t, double* freqs, int pts_in_freqs);</span>
		<span class="n">npts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfFrequencies</span><span class="p">()</span>
		<span class="n">freq_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double[] &quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">npts</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">freq_arr</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">freq_arr</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.setFrequencies"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setFrequencies">[docs]</a>	<span class="k">def</span> <span class="nf">setFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freqs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Set the frequencies to measure during each sweep. Units are MHz.</span>

<span class="sd">		Note that the AVMU frequency generation</span>
<span class="sd">		hardware has fixed precision and so the generated frequency may not be exactly</span>
<span class="sd">		equal to the requested frequency. This function silently converts all requested</span>
<span class="sd">		frequencies to frequencies that can be exactly generated by the hardware.</span>
<span class="sd">		This has important implications for Doppler noise when doing a linear sweep.</span>
<span class="sd">		AKELA recommends using the function :func:`utilFixLinearSweepLimits()` to ensure</span>
<span class="sd">		every frequency is exactly generateable and that the frequencies are equally</span>
<span class="sd">		spaced. Use the :func:`getFrequencies()` function to get the actual frequencies being</span>
<span class="sd">		generated.</span>

<span class="sd">		Args:</span>
<span class="sd">			freqs (list): array of frequencies to sample, in MHz</span>

<span class="sd">		Returns:</span>
<span class="sd">			Nothing</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Too_Many_Points` if N is larger than \</span>
<span class="sd">			                                the maximum allowed (see HardwareDetails)</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Freq_Out_Of_Bounds` if a frequency is \</span>
<span class="sd">			                                beyond the allowed min/max. (You can get the min and max from \</span>
<span class="sd">			                                the HardwareDetails struct returned by :func:`getHardwareDetails()`)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setFrequencies call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setFrequencies(TaskHandle t, const double* freqs, const unsigned int N);</span>
		<span class="n">freq_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double[] &quot;</span><span class="p">,</span> <span class="n">freqs</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">freq_arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getHopRate"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getHopRate">[docs]</a>	<span class="k">def</span> <span class="nf">getHopRate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the frequency hopping rate associated with this Task object.</span>
<span class="sd">		If no rate has yet been set, this function returns ``HOP_UNDEFINED``.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Current hop rate as a string.</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getHopRate call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: HopRate getHopRate(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getHopRate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">ret</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Current hop rate: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">key</span>
		<span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Missing_Hop</span><span class="p">(</span><span class="s2">&quot;getHopRate() returned an unknown hop-rate value: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.setHopRate"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setHopRate">[docs]</a>	<span class="k">def</span> <span class="nf">setHopRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hop_str</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Set the frequency hopping rate. See the values defined in the &quot;HopRate&quot; type above.</span>

<span class="sd">		Args:</span>
<span class="sd">			hop_str (str): The new hop rate.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Nothing</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Hop` if there was something wrong with the hop rate parameter</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the ``TASK_UNINITIALIZED`` or ``TASK_STOPPED`` state</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setHopRate call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setHopRate(TaskHandle t, const HopRate rate);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting hop rate to: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">hop_str</span><span class="p">)</span>
		<span class="k">assert</span> <span class="n">hop_str</span> <span class="o">!=</span> <span class="s2">&quot;HOP_UNDEFINED&quot;</span><span class="p">,</span> <span class="s2">&quot;You cannot set the hop rate to undefined!&quot;</span>
		<span class="k">assert</span> <span class="n">hop_str</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">,</span> <span class="s2">&quot;Invalid hop rate: &#39;</span><span class="si">%s</span><span class="s2">&#39;!&quot;</span> <span class="o">%</span> <span class="n">hop_str</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setHopRate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hops</span><span class="p">[</span><span class="n">hop_str</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getIPAddress"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getIPAddress">[docs]</a>	<span class="k">def</span> <span class="nf">getIPAddress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the current AVMU IP address for the Task object.</span>
<span class="sd">		When no IP has yet been set, this will return a NULL</span>
<span class="sd">		char*.</span>

<span class="sd">		Returns:</span>
<span class="sd">			string of the current remote IP. If the IP is unset, returns ``None``</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getIPAddress call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: const char* getIPAddress(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getIPAddress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">ret</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Null remote IP!&quot;</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">None</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Current remote IP address: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AvmuInterface.setIPAddress"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setIPAddress">[docs]</a>	<span class="k">def</span> <span class="nf">setIPAddress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ip_address</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">		Sets the IPv4 address of the unit to communicate with.  \</span>
<span class="sd">		The ipv4 parameter is copied into the Task&#39;s memory.  \</span>
<span class="sd">		On success the Task&#39;s state will be ``TASK_UNINITIALIZED``. \</span>

<span class="sd">		Args:</span>
<span class="sd">			ip_address (str) IP representation, e.g. &quot;192.168.1.207&quot;, etc...</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State`if the Task is not in the ``TASK_UNINITIALIZED`` or ``TASK_STOPPED`` state</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setIPAddress call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setIPAddress(TaskHandle t, const char* ipv4);</span>
		<span class="k">assert</span> <span class="n">ip_address</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;0123456789.&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;Invalid characters in IP: &#39;</span><span class="si">%s</span><span class="s2">&#39; (full string: &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ip_address</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;0123456789.&quot;</span><span class="p">),</span> <span class="n">ip_address</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting remote IP address to: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ip_address</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setIPAddress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">ip_address</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getIPPort"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getIPPort">[docs]</a>	<span class="k">def</span> <span class="nf">getIPPort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the current port for IP communications. When uninitialized, this will default to 0.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getIPPort call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: int getIPPort(TaskHandle t);</span>
		<span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getIPPort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Current remote IP port: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">port</span></div>

<div class="viewcode-block" id="AvmuInterface.setIPPort"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setIPPort">[docs]</a>	<span class="k">def</span> <span class="nf">setIPPort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		 Sets the port on which to communicate with the unit.</span>

<span class="sd">		The value of `port` MUST be &gt; 1024, as 1024 is reserved</span>
<span class="sd">		for broadcast operations.</span>

<span class="sd">		Note that for multi-unit configurations, each unit must be</span>
<span class="sd">		assigned a unique port &gt; 1024 (the AVMU units listen on all</span>
<span class="sd">		ports, but only respond to broadcast commands on port 1024).</span>
<span class="sd">		On success, the Task&#39;s state will be ``TASK_UNINITIALIZED``.</span>

<span class="sd">		Args:</span>
<span class="sd">			port (int) port number</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State`if the Task is not in the ``TASK_UNINITIALIZED`` or ``TASK_STOPPED`` state</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setIPPort call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setIPPort(TaskHandle t, const int port);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting remote IP port to: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setIPPort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getMeasurementType"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getMeasurementType">[docs]</a>	<span class="k">def</span> <span class="nf">getMeasurementType</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the current measurement ProgramType type.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(str) Current measurement type.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getMeasurementType call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ProgramType getMeasurementType(TaskHandle t);</span>
		<span class="n">prog</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getMeasurementType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">prog_name</span><span class="p">,</span> <span class="n">prog_val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prog_type</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">prog_val</span> <span class="o">==</span> <span class="n">prog</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">prog_name</span>

		<span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Wrong_Program_Type</span><span class="p">(</span><span class="s2">&quot;Unknown program type value (</span><span class="si">%s</span><span class="s2">)!&quot;</span> <span class="o">%</span> <span class="n">prog</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.setMeasurementType"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setMeasurementType">[docs]</a>	<span class="k">def</span> <span class="nf">setMeasurementType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measure_type</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Set the measurement type (synchronous or asynchronous). Note that the AVMU</span>
<span class="sd">		defaults to synchonous (PROG_SYNC).</span>

<span class="sd">		Args:</span>
<span class="sd">			measure_type (str) One of the ProgramType types (``PROG_ASYNC`` or ``PROG_SYNC``).</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setMeasurementType call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setMeasurementType(TaskHandle t, const ProgramType type);</span>
		<span class="k">assert</span> <span class="n">measure_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prog_type</span><span class="p">,</span> <span class="s2">&quot;Invalid measurement type!&quot;</span>
		<span class="n">measurement_type_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prog_type</span><span class="p">[</span><span class="n">measure_type</span><span class="p">]</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setMeasurementType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">measurement_type_code</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

	<span class="c1"># TODO: Also UNTESTED!</span>
<div class="viewcode-block" id="AvmuInterface.setGainSetting"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setGainSetting">[docs]</a>	<span class="k">def</span> <span class="nf">setGainSetting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gain_setting</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Control IF gain.</span>

<span class="sd">		The AVMU has the facility for configurable  gain within the IF stage</span>
<span class="sd">		of the RF pipeline.</span>

<span class="sd">		Args:</span>
<span class="sd">			gain_setting (str) A value in the IfGain Enum (e.g. &quot;AVMU_GAIN_*&quot;)</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the task is either UNINITIALIZED or STOPPED.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setGainSetting call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getIfGain(TaskHandle t, IfGain* new_gain);</span>
		<span class="k">assert</span> <span class="n">gain_setting</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_gain_settings</span><span class="p">,</span> <span class="s2">&quot;Invalid gain value!&quot;</span>
		<span class="n">new_if_gain_enum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_gain_settings</span><span class="p">[</span><span class="n">gain_setting</span><span class="p">]</span>
		<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Specified gain: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gain_setting</span><span class="p">,</span> <span class="n">new_if_gain_enum</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setIfGain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">new_if_gain_enum</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="AvmuInterface.getGainSetting"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getGainSetting">[docs]</a>	<span class="k">def</span> <span class="nf">getGainSetting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the current IF gain setting.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(str) Current IF gain settings.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getGainSetting call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode setIfGain(TaskHandle t, IfGain new_gain);</span>
		<span class="n">current_gain_setting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;int *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getIfGain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">current_gain_setting</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">current_gain_setting</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_gain_inverse</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_gain_inverse</span><span class="p">[</span><span class="n">current_gain_setting</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception</span><span class="p">(</span><span class="s2">&quot;Failed to decode returned gain settings (</span><span class="si">%s</span><span class="s2">)!&quot;</span> <span class="o">%</span> <span class="n">current_gain_setting</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="AvmuInterface.setReceiver12dBPad"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setReceiver12dBPad">[docs]</a>	<span class="k">def</span> <span class="nf">setReceiver12dBPad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">insert_pad</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Control whether an optional 12dB pad is inserted in the internal RF chain.</span>


<span class="sd">		Args:</span>
<span class="sd">			insert_pad (bool): Whether the pad is inserted.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setReceiver12dBPad call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getIfGain(TaskHandle t, IfGain* new_gain);</span>
		<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">insert_pad</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s2">&quot;insert_pad must be a boolean!&quot;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setReceiver12dBPad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">insert_pad</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.getReceiver12dBPad"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getReceiver12dBPad">[docs]</a>	<span class="k">def</span> <span class="nf">getReceiver12dBPad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		TODO: Untested!</span>

<span class="sd">		Get whether the optional 12DB pad is inserted into the RF chain.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(bool) True if pad is enabled.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getReceiver12dBPad call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode setIfGain(TaskHandle t, IfGain new_gain);</span>
		<span class="n">is_inserted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;bool *&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getReceiver12dBPad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">is_inserted</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">is_inserted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getNumberOfFrequencies"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getNumberOfFrequencies">[docs]</a>	<span class="k">def</span> <span class="nf">getNumberOfFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">		Get the number of frequency points for the sweep configured for</span>
<span class="sd">		the Task. If no frequencies have been set, this function returns 0.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(int) Number of frequency points in the current sweep.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getNumberOfFrequencies call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: unsigned int getNumberOfFrequencies(TaskHandle t);</span>
		<span class="n">freqNum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getNumberOfFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">freqNum</span></div>


<div class="viewcode-block" id="AvmuInterface.utilGenerateLinearSweep"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.utilGenerateLinearSweep">[docs]</a>	<span class="k">def</span> <span class="nf">utilGenerateLinearSweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startF_mhz</span><span class="p">,</span> <span class="n">stopF_mhz</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">		Generates a linear sweep with the requested parameters. Note that the start and end</span>
<span class="sd">		frequency will be adjusted as documented in utilFixLinearSweepLimits() so that all</span>
<span class="sd">		frequency points fall on exactly generateable values. This function internally calls</span>
<span class="sd">		setFrequencies() with the resulting array. The caller can retrieve the frequency list</span>
<span class="sd">		with the getFrequencies() function. Since it changes the frequencies this function</span>
<span class="sd">		is only available in the TASK_STOPPED state.</span>

<span class="sd">		If `startFreq` == `endFreq`, the hardware will effectively be placed in zero-span</span>
<span class="sd">		mode, as it will repeatedly sample the same frequency for the duration of the</span>
<span class="sd">		sweep. This is a valid operating mode.</span>

<span class="sd">		Args:</span>
<span class="sd">			startF_mhz (float) Start frequency of sweep in Mhz</span>
<span class="sd">			stopF_mhz (float) End frequency of sweep in Mhz</span>
<span class="sd">			N (int) Number of points to sample</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Too_Many_Points` if N is larger than \</span>
<span class="sd">			                                the maximum allowed (see HardwareDetails)</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Freq_Out_Of_Bounds` if a frequency is \</span>
<span class="sd">			                                beyond the allowed min/max. (You can get the min and max from \</span>
<span class="sd">			                                the HardwareDetails struct returned by :func:`getHardwareDetails()`)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;utilGenerateLinearSweep call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode utilGenerateLinearSweep(TaskHandle t, const double startFreq, const double endFreq, const unsigned int N);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">utilGenerateLinearSweep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">startF_mhz</span><span class="p">,</span> <span class="n">stopF_mhz</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getTimeout"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getTimeout">[docs]</a>	<span class="k">def</span> <span class="nf">getTimeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the current UDP socket transport timeout.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(int) socket timeout, in milliseconds.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getTimeout call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: unsigned int getTimeout(TaskHandle t);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getTimeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Current timeout value: </span><span class="si">%s</span><span class="s2"> ms&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">timeout</span></div>

<div class="viewcode-block" id="AvmuInterface.setTimeout"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setTimeout">[docs]</a>	<span class="k">def</span> <span class="nf">setTimeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout_ms</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Sets the default time to wait, in milliseconds, for a unit to reply to a command</span>
<span class="sd">		before giving up and returning an ERR_NO_RESPONSE condition. For the measurement</span>
<span class="sd">		functions, this is the amount of time to wait beyond the expected sweep time.</span>
<span class="sd">		When a Task is created, the timeout value defaults to 1000.</span>

<span class="sd">		A timeout value of 0 results in non-blocking call, where the call will return</span>
<span class="sd">		immediately if there is no data in the OS receive buffer.</span>

<span class="sd">		Args:</span>
<span class="sd">			timeout_ms (int) - Requested timeout in milliseconds.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Nothing</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setTimeout call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setTimeout(TaskHandle t, const unsigned int timeout);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting socket timeout to: </span><span class="si">%s</span><span class="s2"> ms&quot;</span><span class="p">,</span> <span class="n">timeout_ms</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setTimeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">timeout_ms</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.isSerialPortPresent"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.isSerialPortPresent">[docs]</a>	<span class="k">def</span> <span class="nf">isSerialPortPresent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get whether the remote hardware has a serial port peripheral.</span>

<span class="sd">		Returns:</span>
<span class="sd">			True if the hardware supports a serial port, False if not.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;isSerialPortPresent call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode isSerialPortPresent(TaskHandle t, bool* present);</span>
		<span class="n">present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;bool *&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">isSerialPortPresent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">present</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">present</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AvmuInterface.setSerialPortFeature"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setSerialPortFeature">[docs]</a>	<span class="k">def</span> <span class="nf">setSerialPortFeature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">128</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		If the remote hardware has a serial port, this call configures it.</span>

<span class="sd">		Args:</span>
<span class="sd">			enable (bool) Enables/Disables the reception of serial data by the AVMU.</span>
<span class="sd">			buffer_size (int) Size of the serial RX buffer to allocate. This can be \</span>
<span class="sd">			    any value &gt; 1 and &lt; 255.</span>


<span class="sd">		raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Feature_Not_Present`:   if the remote AVMU \</span>
<span class="sd">			    does not have a serial port.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setSerialPortFeature call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setSerialPortFeature(TaskHandle t, const bool enable, const unsigned int buffer_size);</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">buffer_size</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">serial_buf_sz</span> <span class="o">=</span> <span class="n">buffer_size</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setSerialPortFeature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.isShaftEncoderPresent"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.isShaftEncoderPresent">[docs]</a>	<span class="k">def</span> <span class="nf">isShaftEncoderPresent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get whether the AVMU has support for external shaft encoder inputs.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(bool) whether the connected AVMU has support for encoders</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;isShaftEncoderPresent call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode isShaftEncoderPresent(TaskHandle t, bool* present);</span>
		<span class="n">present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;bool *&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">isShaftEncoderPresent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">present</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">present</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AvmuInterface.setShaftEncoderFeature"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setShaftEncoderFeature">[docs]</a>	<span class="k">def</span> <span class="nf">setShaftEncoderFeature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">resetOnStart</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		If the AVMU supports encoders, this allows you to enable the encoders,</span>
<span class="sd">		and optionally reset the cumulative encoder counter.</span>

<span class="sd">		Args:</span>
<span class="sd">			enable(bool) Tell the hardware to sample the encoders.</span>
<span class="sd">			resetOnStart(bool) Reset the accumulated encoder counter in the hardware \</span>
<span class="sd">			             on sweep start. If this is not set, the value accumulated from \</span>
<span class="sd">			             any previous motion will remain in the accumulator, and be \</span>
<span class="sd">			             present when the hardware is started.</span>


<span class="sd">		raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Feature_Not_Present`:   if the remote AVMU \</span>
<span class="sd">			    does not have encoder support.</span>


<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setShaftEncoderFeature call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setShaftEncoderFeature(TaskHandle t, const bool enable);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setShaftEncoderFeature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">enable</span><span class="p">,</span> <span class="n">resetOnStart</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

	<span class="c1"># Note: UNTESTED!</span>
<div class="viewcode-block" id="AvmuInterface.configureTddSettings"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.configureTddSettings">[docs]</a>	<span class="k">def</span> <span class="nf">configureTddSettings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
				<span class="n">tddEnabled</span>        <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
				<span class="n">nullingEnabled</span>    <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
				<span class="n">powerAmpState</span>     <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
				<span class="n">slave</span>             <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
				<span class="n">attenuatorEnabled</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
				<span class="n">lnaEnabled</span>        <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
				<span class="n">attenuatorValue</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">tx</span>                <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">tx_to_rx1</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">rx1</span>               <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">rx1_to_rx2</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">rx2</span>               <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">rx2_to_tx</span>         <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
			<span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;configureTddSettings call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode setShaftEncoderFeature(TaskHandle t, const bool enable);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">configureTddSettings</span><span class="p">(</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span>
			<span class="kc">True</span><span class="p">,</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">tddEnabled</span><span class="p">),</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">nullingEnabled</span><span class="p">),</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">powerAmpState</span><span class="p">),</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">slave</span><span class="p">),</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">attenuatorEnabled</span><span class="p">),</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">lnaEnabled</span><span class="p">),</span>
			<span class="nb">bool</span><span class="p">(</span><span class="n">attenuatorValue</span><span class="p">),</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">tx</span><span class="p">),</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">tx_to_rx1</span><span class="p">),</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">rx1</span><span class="p">),</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">rx1_to_rx2</span><span class="p">),</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">rx2</span><span class="p">),</span>
			<span class="nb">int</span><span class="p">(</span><span class="n">rx2_to_tx</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

	<span class="c1">###############################################################</span>

<div class="viewcode-block" id="AvmuInterface.getState"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getState">[docs]</a>	<span class="k">def</span> <span class="nf">getState</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		 Get the current state of the Task.</span>

<span class="sd">		Returns:</span>
<span class="sd">			(str) One of &#39;TASK_RUNNING&#39;, &#39;TASK_STARTED&#39;, &#39;TASK_STOPPED&#39; or &#39;TASK_UNINITIALIZED&#39;.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getState call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: TaskState getState(TaskHandle t);</span>
		<span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">state_name</span><span class="p">,</span> <span class="n">state_val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">state_val</span> <span class="o">==</span> <span class="n">state</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">state_name</span>

		<span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception_Wrong_State</span><span class="p">(</span><span class="s2">&quot;State value returned is not known (</span><span class="si">%s</span><span class="s2">)!&quot;</span> <span class="o">%</span> <span class="n">state</span><span class="p">)</span></div>

	<span class="c1">#################################################################################</span>
	<span class="c1">#        Diagnostics</span>
	<span class="c1">#################################################################################</span>

<div class="viewcode-block" id="AvmuInterface.getHardwareDetails"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getHardwareDetails">[docs]</a>	<span class="k">def</span> <span class="nf">getHardwareDetails</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the hardware details for the unit associated with this AvmuInterface instance.</span>

<span class="sd">		TODO: VALIDATE THIS!</span>

<span class="sd">		Args:</span>
<span class="sd">			None</span>

<span class="sd">		Returns:</span>
<span class="sd">			A dictionary of the HardwareDetails members -&gt; value mappings.  \</span>
<span class="sd">			If the Task has not yet been initialized, the returned dict has all values set to 0.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getHardwareDetails call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: HardwareDetails getHardwareDetails(TaskHandle t);</span>
		<span class="n">hardwareDetails</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getHardwareDetails</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s2">&quot;minimum_frequency&quot;</span> <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">minimum_frequency</span><span class="p">,</span>
			<span class="s2">&quot;maximum_frequency&quot;</span> <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">maximum_frequency</span><span class="p">,</span>
			<span class="s2">&quot;maximum_points&quot;</span>    <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">maximum_points</span><span class="p">,</span>
			<span class="s2">&quot;serial_number&quot;</span>     <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">serial_number</span><span class="p">,</span>

			<span class="s2">&quot;band_boundaries&quot;</span>   <span class="p">:</span> <span class="p">[</span><span class="n">hardwareDetails</span><span class="o">.</span><span class="n">band_boundaries</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
										<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hardwareDetails</span><span class="o">.</span><span class="n">number_of_band_boundaries</span><span class="p">)],</span>
			<span class="s2">&quot;switch_board_type&quot;</span> <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">swbd_type</span><span class="p">,</span>
			<span class="s2">&quot;feature_flags&quot;</span>     <span class="p">:</span> <span class="p">{</span>

				<span class="s2">&quot;has_encoders&quot;</span>           <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">hardware_features</span><span class="o">.</span><span class="n">has_encoders</span><span class="p">,</span>
				<span class="s2">&quot;has_serial_port&quot;</span>        <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">hardware_features</span><span class="o">.</span><span class="n">has_serial_port</span><span class="p">,</span>
				<span class="s2">&quot;has_attenuators&quot;</span>        <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">hardware_features</span><span class="o">.</span><span class="n">has_attenuators</span><span class="p">,</span>
				<span class="s2">&quot;has_multiple_receivers&quot;</span> <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">hardware_features</span><span class="o">.</span><span class="n">has_multiple_receivers</span><span class="p">,</span>
				<span class="s2">&quot;has_scan_trigger_in&quot;</span>    <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">hardware_features</span><span class="o">.</span><span class="n">has_scan_trigger_in</span><span class="p">,</span>
				<span class="s2">&quot;has_scan_trigger_out&quot;</span>   <span class="p">:</span> <span class="n">hardwareDetails</span><span class="o">.</span><span class="n">hardware_features</span><span class="o">.</span><span class="n">has_scan_trigger_out</span><span class="p">,</span>

			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AvmuInterface.utilPingUnit"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.utilPingUnit">[docs]</a>	<span class="k">def</span> <span class="nf">utilPingUnit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Sends an &quot;are you there&quot; message to the unit.</span>

<span class="sd">		Note that this function should not be</span>
<span class="sd">		called while a frequency sweep is ongoing, because it causes that sweep to prematurely</span>
<span class="sd">		halt and respond to this message instead. This is only an issue in multithreaded code or</span>
<span class="sd">		when in async mode, as the sync data acquisition functions are blocking. This function</span>
<span class="sd">		waits for a reply for the length of time specified by getTimeout() before giving up.</span>

<span class="sd">		Note that this can be called from any state, provided an IP and port are present.</span>

<span class="sd">		Raises an exception if the unit did not respond, returns nothing otherwise.</span>


<span class="sd">		Raises:</span>

<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Socket` if there was a problem sending a message</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_No_Response` if the unit did not respond to commands</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Missing_Ip` if no IP address has been set</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Missing_Port` if no port has been set</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;utilPingUnit call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode utilPingUnit(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">utilPingUnit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;utilPingUnit return&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="AvmuInterface.versionString"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.versionString">[docs]</a>	<span class="k">def</span> <span class="nf">versionString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns a string describing the version of the DLL and its components.</span>

<span class="sd">		Returns:</span>
<span class="sd">			String describing the AVMU DLL components and version numbers.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;versionString call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: const char* versionString();</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">versionString</span><span class="p">()</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span></div>

	<span class="c1">#################################################################################</span>
	<span class="c1">#        Utilities</span>
	<span class="c1">#################################################################################</span>

<div class="viewcode-block" id="AvmuInterface.utilFixLinearSweepLimits"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.utilFixLinearSweepLimits">[docs]</a>	<span class="k">def</span> <span class="nf">utilFixLinearSweepLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startF</span><span class="p">,</span> <span class="n">endF</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Adjusts the start and end of a requested linear sweep with N points such that all</span>
<span class="sd">		frequencies in the sweep will land on exactly generateable values, and the inter-point</span>
<span class="sd">		spacing is constant across the entire scan. Unequal spacing will cause Doppler noise in</span>
<span class="sd">		the data.</span>

<span class="sd">		This may move the start and end frequencies of the scan slightly (&lt;1 MHz).</span>

<span class="sd">		If the input frequencies are equal, or N is 1, the frequencies are each</span>
<span class="sd">		simply adjusted to exactly generateable values.</span>

<span class="sd">		TODO: VALIDATE THIS!</span>

<span class="sd">		Args:</span>
<span class="sd">			startF(float) - Target start frequency for sweep, in Mhz.</span>
<span class="sd">			endF(float) - Target end frequency for sweep, in Mhz.</span>
<span class="sd">			npts(int) - Number of points to sample, spaced linearly between startFreq and endFreq</span>

<span class="sd">		Returns:</span>
<span class="sd">			Adjusted start and stop frequencies as a 2-tuple</span>


<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Too_Many_Points` if N is larger than \</span>
<span class="sd">			                                the maximum allowed (see HardwareDetails)</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Freq_Out_Of_Bounds` if a frequency is \</span>
<span class="sd">			                                beyond the allowed min/max. (You can get the min and max from \</span>
<span class="sd">			                                the HardwareDetails struct returned by :func:`getHardwareDetails()`)</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;utilFixLinearSweepLimits call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode utilFixLinearSweepLimits(TaskHandle t, double* startFreq, double* endFreq, const unsigned int N);</span>
		<span class="n">startF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">startF</span><span class="p">)</span>
		<span class="n">endF</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">endF</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">utilFixLinearSweepLimits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">startF</span><span class="p">,</span> <span class="n">endF</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">startF</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">endF</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AvmuInterface.utilNearestLegalFreq"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.utilNearestLegalFreq">[docs]</a>	<span class="k">def</span> <span class="nf">utilNearestLegalFreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Adjusts a requested frequency, in MHz, to the nearest able to be generated by the</span>
<span class="sd">		hardware. This is not available in the TASK_UNINITIALIZED state, as it requires knowledge</span>
<span class="sd">		of the hardware not read from the AVMU until initialized.</span>

<span class="sd">		Args:</span>
<span class="sd">			target_freq (float) - Target frequency to be adjusted</span>

<span class="sd">		Returns:</span>
<span class="sd">			Adjusted `target_freq` Frequency value as a float</span>

<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Freq_Out_Of_Bounds` if a frequency is \</span>
<span class="sd">			                                beyond the allowed min/max. (You can get the min and max from \</span>
<span class="sd">			                                the HardwareDetails struct returned by :func:`getHardwareDetails()`)</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;utilNearestLegalFreq call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode utilNearestLegalFreq(TaskHandle t, double* freq);</span>
		<span class="n">freq</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">utilNearestLegalFreq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

	<span class="c1">#################################################################################</span>
	<span class="c1">#        Execution</span>
	<span class="c1">#################################################################################</span>

<div class="viewcode-block" id="AvmuInterface.initialize"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.initialize">[docs]</a>	<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Attempts to talk to the unit specified by the Task&#39;s IP address and port, and download</span>
<span class="sd">		its details. If it succeeds the Task enters the TASK_STOPPED state.</span>

<span class="sd">		Raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Socket` if there was a problem sending a message</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_No_Response` if the unit did not respond to commands</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Missing_Ip` if no IP address has been set</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Missing_Port` if no port has been set</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State`  if the Task is not in the TASK_UNINITIALIZED state</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Prom`  if the unit returned hardware details that this DLL doesn&#39;t understand</span>


<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;initialize call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode initialize(TaskHandle t, progress_callback callback, void* user);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initializing remote device.&quot;</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">NULL</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">NULL</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Remote device initialized.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="AvmuInterface.beginAsync"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.beginAsync">[docs]</a>	<span class="k">def</span> <span class="nf">beginAsync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Begin async data collection.</span>
<span class="sd">		This call emits the trigger message that will cause the remote hardware to</span>
<span class="sd">		immediately begin acquiring frequency data continuously.</span>

<span class="sd">		Note that once beginAsync() has been called, you MUST then call measure()</span>
<span class="sd">		periodically so that the UDP recieve buffer will not overflow.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;beginAsync call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode beginAsync(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">beginAsync</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.broadcastBeginCommand"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.broadcastBeginCommand">[docs]</a>	<span class="k">def</span> <span class="nf">broadcastBeginCommand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handles</span><span class="o">=</span><span class="p">[]):</span>
		<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">		Broadcast a &quot;begin&quot; command to all avmus on the local network. This will start the</span>
<span class="sd">		sweep of every avmu on the network at the current position of its internal PC, and</span>
<span class="sd">		therefore depends on the avmus having been preconfigured to the proper start addresses</span>
<span class="sd">		using beginAsync().</span>

<span class="sd">		Args:</span>
<span class="sd">			handles (list of AvmuInterface) The list of AVMU AvmuInterface instances to start \</span>
<span class="sd">			        in a coordinated manner. Note that if you have all AVMUs in SYNC_IGNORE mode \</span>
<span class="sd">			        this will operate fine, but the AVMUs will not be properly synchronized.</span>

<span class="sd">		Raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if any of the the tasks are not in the TASK_RUNNING state.</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Task_Array_Invalid` if the passed list is empty (handle_count == 0)</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;broadcastBeginCommand call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode beginAsync(TaskHandle t);</span>
		<span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">__getRawTaskHandle</span><span class="p">()</span> <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">]</span>
		<span class="c1"># print(&quot;Handles:&quot;, handles)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">broadcastBeginCommand</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">handles</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.haltAsync"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.haltAsync">[docs]</a>	<span class="k">def</span> <span class="nf">haltAsync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This causes an immediate halt of the async sweep acquisition in the</span>
<span class="sd">		remote hardware.</span>

<span class="sd">		Any pending data in the UDP recieve buffer will be flushed, and the</span>
<span class="sd">		hardware will be returned to the &quot;started&quot; state.</span>

<span class="sd">		To resume async data collection after calling haltAsync(),</span>
<span class="sd">		simply call beginAsync().</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;haltAsync call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode haltAsync(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">haltAsync</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.interruptMeasurement"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.interruptMeasurement">[docs]</a>	<span class="k">def</span> <span class="nf">interruptMeasurement</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Interrupts one of the measurement functions while it is waiting for data.</span>

<span class="sd">		Since the measurement functions are blocking in SYNC mode, this function</span>
<span class="sd">		must be called from a different thread. This function returns immediately,</span>
<span class="sd">		however the measurement function may continue to block for a short additional</span>
<span class="sd">		amount of time.</span>

<span class="sd">		Raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STARTED state</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;interruptMeasurement call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode interruptMeasurement(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">interruptMeasurement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.start"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.start">[docs]</a>	<span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Attempts to program the AVMU using the settings stored in the Task object. If it</span>
<span class="sd">		succeeds the Task enters the TASK_STARTED state.</span>


<span class="sd">		Raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State`  if the Task is not in the TASK_STOPPED state</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Socket` if there was a problem sending a message</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_No_Response` if the unit did not respond to commands</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Prom`  if the unit returned hardware details that this DLL doesn&#39;t understand</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Hop` if the hop rate has not yet been specified</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Missing_Freqs` if the frequencies have not yet been specified</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Prog_Overflow` if the size of the program is too large for the hardware&#39;s memory \</span>
<span class="sd">				(this can happen if there are too many frequencies)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;start call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode start(TaskHandle t);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting task.&quot;</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="AvmuInterface.stop"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.stop">[docs]</a>	<span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		 Puts the Task object into the TASK_STOPPED state.</span>

<span class="sd">		Raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State`  if the Task is not in the TASK_STARTED state</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;stop call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode stop(TaskHandle t);</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Stopping task.&quot;</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>



<div class="viewcode-block" id="AvmuInterface.measure"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.measure">[docs]</a>	<span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Take a measurement.</span>

<span class="sd">		In PROG_SYNC mode, this triggers a measurement, and blocks until its response has</span>
<span class="sd">		been fully received and decoded.</span>

<span class="sd">		This function does various things depending on the sweep trigger type and the program type.</span>
<span class="sd">		Sync mode, internal trigger: run avmu program, block until data is received or timeout</span>
<span class="sd">		Sync mode, external trigger: block until data is received or timeout</span>
<span class="sd">		Async mode, internal trigger: block until 1 program&#39;s worth of data is received or timeout</span>
<span class="sd">		Async mode, external trigger: block until 1 program&#39;s worth of data is received or timeout</span>

<span class="sd">		Note that beginAsync() must be called prior to measure() in async mode.</span>
<span class="sd">		The pattern is beginAsync(), measure(), measure(), measure(), ..., haltAsync()</span>

<span class="sd">		If the AvmuTask is in async mode (setMeasurementType called with PROG_ASYNC)</span>
<span class="sd">		this simply serves to consume any UDP messages generated by the hardware. Note that</span>
<span class="sd">		since the hardware asynchronously emits data continuously, you therefore</span>
<span class="sd">		*must* call this periodically, or you risk overrunning the socket receive buffer.</span>

<span class="sd">		Typically, overrunning the buffer will result in a ``Avmu_Exception_Bytes`` return code, but</span>
<span class="sd">		it&#39;s theoretically possible to have an entire sweep be dropped (either if it</span>
<span class="sd">		fits in a single packet, or if all the packets for the sweep get dropped).</span>

<span class="sd">		In this case, the only indicator of data loss will be a non-monotonic sweep</span>
<span class="sd">		number in the returned data.</span>

<span class="sd">		In general, it&#39;s probably ideal to just continualy call this.</span>

<span class="sd">		In both cases, measure() places the acquired data in the RX queue, ready</span>
<span class="sd">		to be extracted by calling extractSweepData().</span>

<span class="sd">		Raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the AvmuInterface is in PROG_SYNC mode, and the AvmuInterface \</span>
<span class="sd">		                         state is not TASK_STARTED.</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the AvmuInterface is in PROG_ASYNC mode, and the AvmuInterface \</span>
<span class="sd">		                         state is not TASK_RUNNING.</span>

<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Bytes` if the received data is corrupted in some manner, or incomplete.</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_No_Measured_Paths` if there are no paths added to measure.</span>

<span class="sd">		Rare ``Avmu_Exception_Bytes``, particularly when not on a dedicated subnet are</span>
<span class="sd">		not entirely unknown, but they shouldn&#39;t happen frequently.</span>

<span class="sd">		If you encounter large numbers of ``Avmu_Exception_Bytes`` returns, there can be a number of</span>
<span class="sd">		causes. TCP Checksum offloading has been known to cause this, as could</span>
<span class="sd">		not calling measure() frequently enough. Lastly, check the intervening network</span>
<span class="sd">		hardware. You might have a failing switch/hub.</span>

<span class="sd">		Note that the AVMU hardware is particularly intolerant of network hubs,</span>
<span class="sd">		as its UDP transport does not support data retransmits. Any collisions</span>
<span class="sd">		will result in a corrupted sweep (but really, it&#39;s 2018+, why are you</span>
<span class="sd">		running a network hub?).</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;measure call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode measure(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>


<div class="viewcode-block" id="AvmuInterface.getnumberOfEnabledReceivers"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getnumberOfEnabledReceivers">[docs]</a>	<span class="k">def</span> <span class="nf">getnumberOfEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns the number of receivers in the AVMU.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getnumberOfEnabledReceivers call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getnumberOfEnabledReceivers(TaskHandle t, int*  num_receivers_enabled);</span>
		<span class="n">present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;int *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getnumberOfEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">present</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">present</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

	<span class="k">def</span> <span class="nf">__decodeEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable_bitmap</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__decodeEnabledReceivers call&quot;</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">enable_bitmap</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">:</span>
				<span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="AvmuInterface.getEnabledReceivers"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getEnabledReceivers">[docs]</a>	<span class="k">def</span> <span class="nf">getEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns a list describing which of the AVMU&#39;s receivers will return data.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getEnabledReceivers call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getEnabledReceivers(TaskHandle t,         char* enabled_receivers_mask);</span>
		<span class="c1"># Use an int8_t because it casts to char cleanly, but</span>
		<span class="c1"># doesn&#39;t try to act like a bytes character everywhere.</span>
		<span class="n">enable_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;int8_t *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;char *&quot;</span><span class="p">,</span> <span class="n">enable_mask</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">active_receivers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__decodeEnabledReceivers</span><span class="p">(</span><span class="n">enable_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_receivers</span></div>

	<span class="k">def</span> <span class="nf">__setEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable_mask</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__setEnabledReceivers call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode setEnabledReceivers(TaskHandle t,         char  enabled_receivers_mask);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="n">enable_mask</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="c1"># Query and update the enabled recievers config</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">getEnabledReceivers</span><span class="p">()</span>

<div class="viewcode-block" id="AvmuInterface.setEnabledReceivers"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setEnabledReceivers">[docs]</a>	<span class="k">def</span> <span class="nf">setEnabledReceivers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enable_list</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Configure which of the receivers in the AVMU will return data.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setEnabledReceivers call&quot;</span><span class="p">)</span>
		<span class="n">valid_receivers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
		<span class="k">assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">tmp</span> <span class="ow">in</span> <span class="n">valid_receivers</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">enable_list</span><span class="p">]))</span>

		<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">enable_list</span><span class="p">:</span>
			<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">item</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__setEnabledReceivers</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>

	<span class="k">def</span> <span class="nf">__extract_sweep_data_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx_p_enum</span><span class="p">,</span> <span class="n">rx_p_enum</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__extract_sweep_data_int call&quot;</span><span class="p">)</span>

		<span class="n">point_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfFrequencies</span><span class="p">()</span>
		<span class="n">recs</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getEnabledReceivers</span><span class="p">()</span>

		<span class="c1"># print(&quot;getEnabledReceivers: &quot;, self.getEnabledReceivers())</span>

		<span class="n">sdat_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;SweepDataStruct *&quot;</span><span class="p">)</span>
		<span class="n">sdat_struct</span><span class="o">.</span><span class="n">serial_data_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;unsigned char [</span><span class="si">{size}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serial_buf_sz</span><span class="p">))</span>

		<span class="n">receiver_arrs</span> <span class="o">=</span> <span class="p">[</span>
				<span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
			<span class="k">for</span>
				<span class="n">dummy</span>
			<span class="ow">in</span>
				<span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">))</span>
		<span class="p">]</span>

		<span class="n">i_initializer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">receiver_arrs</span><span class="p">]</span>
		<span class="n">q_initializer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">receiver_arrs</span><span class="p">]</span>

		<span class="n">iarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double*[]&quot;</span><span class="p">,</span> <span class="n">i_initializer</span><span class="p">)</span>
		<span class="n">qarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double*[]&quot;</span><span class="p">,</span> <span class="n">q_initializer</span><span class="p">)</span>

		<span class="n">sdat_struct</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">I</span> <span class="o">=</span> <span class="n">iarr</span>
		<span class="n">sdat_struct</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">qarr</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">extractSweepData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">sdat_struct</span><span class="p">,</span> <span class="n">tx_p_enum</span><span class="p">,</span> <span class="n">rx_p_enum</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="c1"># There&#39;s an extra copy here I don&#39;t like. Not sure how to work around it, though.</span>

		<span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">)):</span>
			<span class="n">result</span><span class="p">[</span><span class="n">recs</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

			<span class="n">result</span><span class="p">[</span><span class="n">recs</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">receiver_arrs</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">result</span><span class="p">[</span><span class="n">recs</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">receiver_arrs</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

		<span class="c1"># print(&quot;ExtractAllPaths I mean: {}, Q mean: {}&quot;.format(np.mean(i), np.mean(q)))</span>

		<span class="n">result_meta</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;avmu_ip&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getIPAddress</span><span class="p">(),</span>
			<span class="s1">&#39;tx_port&#39;</span>   <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_enum_int</span><span class="p">[</span><span class="n">tx_p_enum</span><span class="p">],</span>
			<span class="s1">&#39;tx_port_s&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_enum_str</span><span class="p">[</span><span class="n">tx_p_enum</span><span class="p">],</span>
			<span class="s1">&#39;rx_port&#39;</span>   <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_enum_int</span><span class="p">[</span><span class="n">rx_p_enum</span><span class="p">],</span>
			<span class="s1">&#39;rx_port_s&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_enum_str</span><span class="p">[</span><span class="n">rx_p_enum</span><span class="p">],</span>

			<span class="s1">&#39;timestamp_ticks&#39;</span>     <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">timestamp_ticks</span><span class="p">,</span>
			<span class="s1">&#39;timestamp_seconds&#39;</span>   <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">timestamp_seconds</span><span class="p">,</span>
			<span class="s1">&#39;sweep_number&#39;</span>        <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">sweep_number</span><span class="p">,</span>

			<span class="s1">&#39;shaft_encoder_left&#39;</span>  <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">shaft_encoder_left</span><span class="p">,</span>
			<span class="s1">&#39;shaft_encoder_right&#39;</span> <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">shaft_encoder_right</span><span class="p">,</span>

			<span class="s1">&#39;serial_data_age&#39;</span>   <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">serial_data_age</span><span class="p">,</span>
			<span class="s1">&#39;serial_data_bytes&#39;</span> <span class="p">:</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">sdat_struct</span><span class="o">.</span><span class="n">serial_data_bytes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serial_buf_sz</span><span class="p">)]),</span>

		<span class="p">}</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">result_meta</span>



	<span class="k">def</span> <span class="nf">__extract_sweep_data_int_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx_p_enum</span><span class="p">,</span> <span class="n">rx_p_enum</span><span class="p">,</span> <span class="n">did_transmit</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__extract_sweep_data_int_old call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode extractSweepData(TaskHandle t, RFPath path, SweepDataStruct* data);</span>

		<span class="n">point_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getNumberOfFrequencies</span><span class="p">()</span>
		<span class="n">sdat_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;SweepDataStruct *&quot;</span><span class="p">)</span>
		<span class="n">sdat_struct</span><span class="o">.</span><span class="n">serial_data_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;unsigned char [</span><span class="si">{size}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serial_buf_sz</span><span class="p">))</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>


		<span class="n">sdat_struct</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
		<span class="n">sdat_struct</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">extractSweepData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">sdat_struct</span><span class="p">,</span> <span class="n">tx_p_enum</span><span class="p">,</span> <span class="n">rx_p_enum</span><span class="p">,</span> <span class="n">did_transmit</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">point_num</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

		<span class="c1"># There&#39;s an extra copy here I don&#39;t like. Not sure how to work around it, though.</span>
		<span class="n">result</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">i</span>
		<span class="n">result</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">q</span>
		<span class="n">result_meta</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;tx_port&#39;</span>   <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_enum_int</span><span class="p">[</span><span class="n">tx_p_enum</span><span class="p">],</span>
			<span class="s1">&#39;tx_port_s&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_enum_str</span><span class="p">[</span><span class="n">tx_p_enum</span><span class="p">],</span>
			<span class="s1">&#39;rx_port&#39;</span>   <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_enum_int</span><span class="p">[</span><span class="n">rx_p_enum</span><span class="p">],</span>
			<span class="s1">&#39;rx_port_s&#39;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_enum_str</span><span class="p">[</span><span class="n">rx_p_enum</span><span class="p">],</span>

			<span class="s1">&#39;timestamp_ticks&#39;</span>     <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">timestamp_ticks</span><span class="p">,</span>
			<span class="s1">&#39;timestamp_seconds&#39;</span>   <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">timestamp_seconds</span><span class="p">,</span>
			<span class="s1">&#39;sweep_number&#39;</span>        <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">sweep_number</span><span class="p">,</span>

			<span class="s1">&#39;shaft_encoder_left&#39;</span>  <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">shaft_encoder_left</span><span class="p">,</span>
			<span class="s1">&#39;shaft_encoder_right&#39;</span> <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">shaft_encoder_right</span><span class="p">,</span>

			<span class="s1">&#39;serial_data_age&#39;</span>   <span class="p">:</span> <span class="n">sdat_struct</span><span class="o">.</span><span class="n">serial_data_age</span><span class="p">,</span>
			<span class="s1">&#39;serial_data_bytes&#39;</span> <span class="p">:</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">sdat_struct</span><span class="o">.</span><span class="n">serial_data_bytes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serial_buf_sz</span><span class="p">)]),</span>

		<span class="p">}</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">result_meta</span>


<div class="viewcode-block" id="AvmuInterface.extractSweepData"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.extractSweepData">[docs]</a>	<span class="k">def</span> <span class="nf">extractSweepData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx_path</span><span class="p">,</span> <span class="n">rx_path</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Extract the sweep data for a given path described by a TX port and RX port.</span>

<span class="sd">		Note that this interface has the limitation that it does not support multiple measurements</span>
<span class="sd">		of the same path within the overall AVMU acqusision frame.</span>

<span class="sd">		Args:</span>
<span class="sd">			tx_path (str): TX port of the path to extract.</span>
<span class="sd">			rx_path (str): RX port of the path to extract.</span>

<span class="sd">		Returns:</span>
<span class="sd">			- A 2-tuple of containing (data, metadata)</span>
<span class="sd">			    data is a numpy complex array with the dimensions of 1 x ``getNumberOfFrequencies()``,</span>
<span class="sd">			      where each value bin corresponds to the associated frequency bin in ``getFrequencies()``.</span>
<span class="sd">			    metadata is a dict containing the sweep metadata associated with the sweep ``data``.</span>
<span class="sd">			      It contains the following key-&gt; value pairs:</span>
<span class="sd">				- ``tx_port`` - Transmitting port, as a integer.</span>
<span class="sd">				- ``tx_port_s`` - Transmitting port, as a string compatible with ``addPathToMeasure()``.</span>
<span class="sd">				- ``rx_port`` - Receiving port, as a integer.</span>
<span class="sd">				- ``rx_port_s`` - Receiving port, as a string compatible with ``addPathToMeasure()``.</span>
<span class="sd">				- ``timestamp_ticks``   Currently unused. Read as zero.</span>
<span class="sd">				- ``timestamp_seconds`` Currently unused. Read as zero.</span>
<span class="sd">				- ``sweep_number``      Monotonically increasing counter of the number of sweeps (note:</span>
<span class="sd">					sweeps, not frames)</span>
<span class="sd">				- ``shaft_encoder_left``  Shaft encoder accumulator for the left-hand shaft encoder.</span>
<span class="sd">				    If not enabled, will return 0.</span>
<span class="sd">				- ``shaft_encoder_right`` Shaft encoder accumulator for the right-hand shaft encoder.</span>
<span class="sd">				    If not enabled, will return 0.</span>
<span class="sd">				- ``serial_data_age`` Age of the serial port data. If serial is not enabled, will return 0.</span>
<span class="sd">				- ``serial_data_bytes`` Serial data itself, as a bytes array. If not enabled, will be an empty bytes object.</span>

<span class="sd">		raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Bad_Path`:   if a path value specified is invalid.</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;extractSweepData call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode extractSweepData(TaskHandle t, RFPath path, SweepDataStruct* data);</span>
		<span class="k">assert</span> <span class="n">tx_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths</span><span class="p">,</span> <span class="s2">&quot;Invalid path!&quot;</span>
		<span class="k">assert</span> <span class="n">rx_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths</span><span class="p">,</span> <span class="s2">&quot;Invalid path!&quot;</span>
		<span class="n">tx_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths</span><span class="p">[</span><span class="n">tx_path</span><span class="p">]</span>
		<span class="n">rx_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths</span><span class="p">[</span><span class="n">rx_path</span><span class="p">]</span>

		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extract_sweep_data_int</span><span class="p">(</span><span class="n">tx_p</span><span class="p">,</span> <span class="n">rx_p</span><span class="p">)</span></div>

	<span class="k">def</span> <span class="nf">__extractSweepDataIntPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx_path_int</span><span class="p">,</span> <span class="n">rx_path_int</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;__extractSweepDataIntPath call&quot;</span><span class="p">)</span>
		<span class="c1"># Signature: ErrCode extractSweepData(TaskHandle t, RFPath path, SweepDataStruct* data);</span>
		<span class="k">assert</span> <span class="n">tx_path_int</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_int_enum</span><span class="p">,</span> <span class="s2">&quot;Invalid path!&quot;</span>
		<span class="k">assert</span> <span class="n">rx_path_int</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_int_enum</span><span class="p">,</span> <span class="s2">&quot;Invalid path!&quot;</span>
		<span class="n">tx_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tx_paths_int_enum</span><span class="p">[</span><span class="n">tx_path_int</span><span class="p">]</span>
		<span class="n">rx_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rx_paths_int_enum</span><span class="p">[</span><span class="n">rx_path_int</span><span class="p">]</span>

		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extract_sweep_data_int</span><span class="p">(</span><span class="n">tx_p</span><span class="p">,</span> <span class="n">rx_p</span><span class="p">)</span>

<div class="viewcode-block" id="AvmuInterface.extractAllPaths"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.extractAllPaths">[docs]</a>	<span class="k">def</span> <span class="nf">extractAllPaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Given a set of measured paths that are unique, extract every path and return them</span>
<span class="sd">		as a list.</span>

<span class="sd">		This call presumes the user has called ``measure()`` prior to it&#39;s invocation.</span>
<span class="sd">		If not, it will raise :class:`~avmu.avmu_exceptions.Avmu_Exception_Path_Has_No_Data`:   if you didn&#39;t call ``measure()``</span>

<span class="sd">		Returns:</span>
<span class="sd">			A list of 2-tuples ``(path_info, data)``.</span>

<span class="sd">			``path_info`` is a dict containing the following:</span>

<span class="sd">				- ``who_is_transmitting``  Which unit is doing the transmitting. This is</span>
<span class="sd">				  only relevant in a multi-AVMU context. Single-AVMU setups can ignore it.</span>
<span class="sd">				- ``port_is_transmitting``   Which port on the transmitting unit is active. This is</span>
<span class="sd">				  only relevant in a multi-AVMU context. Single-AVMU setups can ignore it.</span>
<span class="sd">				- ``tx_path``              Which port on the current AVMU is transmitting. For multi AVMU</span>
<span class="sd">				  configurations, when the current AVMU is not transmitting, this will be TX_NONE.</span>
<span class="sd">				- ``rx_path``              Which port on the current AVMU is receiving.</span>
<span class="sd">				- ``receiver_channel``     Which receiver is the dataset for. At the moment, this</span>
<span class="sd">				  is ALWAYS 0, as no multi-receiver AVMUs are available.</span>


<span class="sd">				In the general single-unit case, you can ignore all the keys other then ``tx_path`` and ``rx_path``.</span>

<span class="sd">			``data`` is a dict containing two keys:</span>

<span class="sd">				- ``data`` The actual sweep&#39;s data. This is directly the ``data`` return component from</span>
<span class="sd">				  the ``extractSweepData()`` call.</span>
<span class="sd">				- ``meta`` The sweep&#39;s metadata. This is directly the ``metadata`` return component from</span>
<span class="sd">				  the ``extractSweepData()`` call.</span>

<span class="sd">		raises:</span>
<span class="sd">			:class:`~avmu.avmu_exceptions.Avmu_Exception_Path_Has_No_Data`:   if you didn&#39;t call ``measure()``</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;extractAllPaths call&quot;</span><span class="p">)</span>
		<span class="c1"># Python-only convenience function.</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="c1"># print(&quot;extractAllPaths() for radar &quot;, self.getIPAddress())</span>
		<span class="k">for</span> <span class="n">who_is_transmitting</span><span class="p">,</span> <span class="n">port_is_transmitting</span><span class="p">,</span> <span class="n">tx_path</span><span class="p">,</span> <span class="n">rx_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">measured_paths</span><span class="p">:</span>
			<span class="c1"># print(&quot;Extracting path: &quot;, tx_path, rx_path, transmitted)</span>
			<span class="n">rx_dict</span><span class="p">,</span> <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extractSweepDataIntPath</span><span class="p">(</span><span class="n">tx_path</span><span class="p">,</span> <span class="n">rx_path</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">receiver_channel</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">rx_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
				<span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span>
					<span class="p">{</span>
						<span class="s1">&#39;who_is_transmitting&#39;</span>  <span class="p">:</span> <span class="n">who_is_transmitting</span><span class="p">,</span>
						<span class="s1">&#39;port_is_transmitting&#39;</span> <span class="p">:</span> <span class="n">port_is_transmitting</span><span class="p">,</span>
						<span class="s1">&#39;tx_path&#39;</span>              <span class="p">:</span> <span class="n">tx_path</span><span class="p">,</span>
						<span class="s1">&#39;rx_path&#39;</span>              <span class="p">:</span> <span class="n">rx_path</span><span class="p">,</span>
						<span class="s1">&#39;receiver_channel&#39;</span>     <span class="p">:</span> <span class="n">receiver_channel</span><span class="p">,</span>
					<span class="p">},</span>
					<span class="p">{</span>
						<span class="s1">&#39;data&#39;</span> <span class="p">:</span> <span class="n">data</span><span class="p">,</span>
						<span class="s1">&#39;meta&#39;</span> <span class="p">:</span> <span class="n">meta</span>
					<span class="p">}</span>
					<span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="AvmuInterface.setSyncPulseMode"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.setSyncPulseMode">[docs]</a>	<span class="k">def</span> <span class="nf">setSyncPulseMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sync_mode</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Configure the inter-AVMU synchronization pulse mode for the specified AVMU.</span>

<span class="sd">		The SyncPulseMode is used to allow coordinated acquisition between</span>
<span class="sd">		multiple AVMUs. In coordinated operation, the master unit is set to</span>
<span class="sd">		SYNC_GENERATE, and any slave units are set to SYNC_RECEIVE. This</span>
<span class="sd">		causes the master to emit sweep start outputs, which are consumed</span>
<span class="sd">		by the slave units.</span>

<span class="sd">		Note that this requires specialized hardware support, and dedicated</span>
<span class="sd">		syncronization wiring.</span>

<span class="sd">		Additionally, to properly synchronize, all units must receive their</span>
<span class="sd">		start command within 1 ms of each other, which is accomplished via</span>
<span class="sd">		the broadcastBeginCommand() call. This also requires the</span>
<span class="sd">		shared-communication-infrasturcture provided by the createSharedTask()</span>
<span class="sd">		call. All AVMU tasks used in a coordinated acqusition must share</span>
<span class="sd">		their internal communication object.</span>

<span class="sd">		Args:</span>
<span class="sd">			sync_mode (str) One of &quot;SYNC_IGNORE&quot;, &quot;SYNC_GENERATE&quot; or &quot;SYNC_RECEIVE&quot;</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State`if the Task is not in the ``TASK_UNINITIALIZED`` or ``TASK_STOPPED`` state</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;setSyncPulseMode call&quot;</span><span class="p">)</span>
		<span class="k">assert</span> <span class="n">sync_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_pulse_mode</span>

		<span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_pulse_mode</span><span class="p">[</span><span class="n">sync_mode</span><span class="p">]</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">setSyncPulseMode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.getSyncPulseMode"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getSyncPulseMode">[docs]</a>	<span class="k">def</span> <span class="nf">getSyncPulseMode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the current sync pulse mode for this unit.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Current sync-pulse mode as a string.</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getSyncPulseMode call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getnumberOfEnabledReceivers(TaskHandle t, int*  num_receivers_enabled);</span>
		<span class="n">sync_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;int *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getSyncPulseMode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">sync_mode</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_pulse_mode</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">sync_mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
				<span class="k">return</span> <span class="n">key</span>

		<span class="k">raise</span> <span class="n">avmu_exceptions</span><span class="o">.</span><span class="n">Avmu_Exception</span><span class="p">(</span><span class="s2">&quot;Failed to decode returned sync pulse mode (</span><span class="si">%s</span><span class="s2">)!&quot;</span> <span class="o">%</span> <span class="n">sync_mode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="AvmuInterface.addExclusionBand"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.addExclusionBand">[docs]</a>	<span class="k">def</span> <span class="nf">addExclusionBand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_freq</span><span class="p">,</span> <span class="n">stop_freq</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Exclusion bands are used to prevent the AVMU from transmitting in specific</span>
<span class="sd">		frequency ranges. This is generally used to &quot;mask out&quot; sensitive RF regions,</span>
<span class="sd">		so things like GPS are not negatively affected by the AVMU.</span>

<span class="sd">		The AVMU will still take data at points within the exclusion band, but</span>
<span class="sd">		the RF output will be disabled.</span>

<span class="sd">		Multiple exclusion bands are logically ORed together. Basically, if</span>
<span class="sd">		a frequency point falls within *any* exclusion band, it will result in the</span>
<span class="sd">		RF output being disabled.</span>

<span class="sd">		As such, repeated or overlapping exclusion bands are valid (though</span>
<span class="sd">		they are somewhat pointless).</span>

<span class="sd">		Note that you cannot add exclusion bands before connecting to an AVMU.</span>

<span class="sd">		Note that start_freq must be smaller then stop_freq.</span>

<span class="sd">		Args:</span>
<span class="sd">			start_freq (float, MHz) - Start of the exclusion band</span>
<span class="sd">			stop_freq (float, MHz) - End of the exclusion band (MUST be larger then start_freq)</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;addExclusionBand call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode addExclusionBand(TaskHandle t, double start_freq, double stop_freq);</span>
		<span class="k">assert</span> <span class="n">stop_freq</span> <span class="o">&gt;</span> <span class="n">start_freq</span><span class="p">,</span> <span class="s2">&quot;The stop frequency must be larger then the start frequency&quot;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">addExclusionBand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">start_freq</span><span class="p">,</span> <span class="n">stop_freq</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.clearExclusionBands"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.clearExclusionBands">[docs]</a>	<span class="k">def</span> <span class="nf">clearExclusionBands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Clear the internal list of exclusion bands stored in the AvmuInterface.</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Err_Invalid_Parameter` if the parameters do not make sense.</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;clearExclusionBands call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode clearExclusionBands(TaskHandle t);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">clearExclusionBands</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>

<div class="viewcode-block" id="AvmuInterface.getExclusionBandCount"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getExclusionBandCount">[docs]</a>	<span class="k">def</span> <span class="nf">getExclusionBandCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the number of separate exclusion bands configured in the AvmuInterface.</span>

<span class="sd">		This is required to enumerate the active exclusion bands.</span>

<span class="sd">		Returns:</span>
<span class="sd">			exclusion_band_count(int) number of exclusion bands configured.</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getExclusionBandCount call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getExclusionBandCount(TaskHandle t, int* idx);</span>

		<span class="n">exclusion_band_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;int *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getExclusionBandCount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">exclusion_band_count</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">exclusion_band_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AvmuInterface.getExclusionBand"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getExclusionBand">[docs]</a>	<span class="k">def</span> <span class="nf">getExclusionBand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band_idx</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the (start_f_mhz, stop_f_mhz) values for exclusion band band_idx.</span>

<span class="sd">		Given a index of 0 &lt;= idx &lt; getExclusionBandCount(), return</span>
<span class="sd">		the corresponding exclusion band start/end frequency.</span>

<span class="sd">		Return:</span>
<span class="sd">			2-tuple of start_f_mhz (double), stop_f_mhz (double)</span>

<span class="sd">		Raises:</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Wrong_State` if the Task is not in the TASK_STOPPED state</span>
<span class="sd">			 :class:`~avmu.avmu_exceptions.Avmu_Exception_Err_Index_Out_Of_Bounds` if the specified index is not valid.  \</span>
<span class="sd">			                                                                      Note that when no exclusion bands are  \</span>
<span class="sd">			                                                                      specified, ALL possible values for idx  \</span>
<span class="sd">			                                                                      are therefore invalid.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getExclusionBand call&quot;</span><span class="p">)</span>
		<span class="c1"># ErrCode getExclusionBand(TaskHandle t, int idx, double* start_freq, double* stop_freq);</span>

		<span class="n">start_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">stop_f</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;double *&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getExclusionBand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">,</span> <span class="n">band_idx</span><span class="p">,</span> <span class="n">start_f</span><span class="p">,</span> <span class="n">stop_f</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">__check_ret</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">start_f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stop_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="AvmuInterface.getPreciseTimePerFrame"><a class="viewcode-back" href="../../index.html#avmu.AvmuInterface.getPreciseTimePerFrame">[docs]</a>	<span class="k">def</span> <span class="nf">getPreciseTimePerFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Get the precise time (in seconds) that a Frame will take.</span>

<span class="sd">		This function only operates properly when a AVMU is in the started or running states, as</span>
<span class="sd">		the sweep program is not computed until the transition to the started state.</span>

<span class="sd">		Returns:</span>
<span class="sd">			Frame time, as a double, in fractional seconds.</span>
<span class="sd">			     If the task is not valid, or in the correct state,</span>
<span class="sd">			     the return value is -1.</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dll</span><span class="o">.</span><span class="n">getPreciseTimePerFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task_handle</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">ret</span></div></div>




</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Akela AVMU</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Akela Inc.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>